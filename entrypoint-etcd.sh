#!/bin/sh
# Pingap + etcd Dynamic Proxy Entrypoint
#
# This script:
# 1. Writes TLS certificates from environment variables
# 2. Waits for etcd to become available
# 3. Bootstraps initial configuration if etcd is empty
# 4. Starts Pingap with etcd backend and autoreload
#
# Environment variables:
#   PINGAP_TLS_CERT     - Cloudflare Origin Certificate (PEM)
#   PINGAP_TLS_KEY      - Private key (PEM)
#   PINGAP_ETCD_ADDR    - etcd address (default: http://etcd:2379)
#   PINGAP_ETCD_PREFIX  - etcd key prefix (default: /pingap/config)
#   PINGAP_ADMIN_ADDR   - Admin interface address (default: 0.0.0.0:3018)
#   ETCD_ROOT_PASSWORD  - etcd root password (optional)

set -e

CERT_DIR="/etc/pingap/certs"
CONFIG_DIR="/etc/pingap"
ETCD_ADDR="${PINGAP_ETCD_ADDR:-http://etcd:2379}"
ETCD_PREFIX="${PINGAP_ETCD_PREFIX:-/pingap/config}"
ADMIN_ADDR="${PINGAP_ADMIN_ADDR:-0.0.0.0:3018}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Write TLS certificates from environment variables
write_certificates() {
    log "Writing TLS certificates..."
    mkdir -p "$CERT_DIR"

    if [ -n "$PINGAP_TLS_CERT" ]; then
        # Handle both escaped newlines and literal newlines
        printf '%s' "$PINGAP_TLS_CERT" | sed 's/\\n/\n/g' > "$CERT_DIR/origin.crt"
        log "Certificate written to $CERT_DIR/origin.crt"
    else
        log "WARNING: PINGAP_TLS_CERT not set, HTTPS will not work"
    fi

    if [ -n "$PINGAP_TLS_KEY" ]; then
        printf '%s' "$PINGAP_TLS_KEY" | sed 's/\\n/\n/g' > "$CERT_DIR/origin.key"
        chmod 600 "$CERT_DIR/origin.key"
        log "Private key written to $CERT_DIR/origin.key"
    else
        log "WARNING: PINGAP_TLS_KEY not set, HTTPS will not work"
    fi
}

# Wait for etcd to be available
wait_for_etcd() {
    log "Waiting for etcd at $ETCD_ADDR..."

    ETCD_AUTH=""
    if [ -n "$ETCD_ROOT_PASSWORD" ]; then
        ETCD_AUTH="--user=root:$ETCD_ROOT_PASSWORD"
    fi

    max_attempts=60
    attempt=1

    while [ $attempt -le $max_attempts ]; do
        if etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH endpoint health 2>/dev/null; then
            log "etcd is healthy"
            return 0
        fi
        log "Waiting for etcd (attempt $attempt/$max_attempts)..."
        sleep 2
        attempt=$((attempt + 1))
    done

    log "ERROR: etcd did not become available after $max_attempts attempts"
    exit 1
}

# Check if etcd has existing configuration
etcd_has_config() {
    ETCD_AUTH=""
    if [ -n "$ETCD_ROOT_PASSWORD" ]; then
        ETCD_AUTH="--user=root:$ETCD_ROOT_PASSWORD"
    fi

    # Check if any keys exist under our prefix
    result=$(etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH get "$ETCD_PREFIX" --prefix --keys-only 2>/dev/null | head -1)
    [ -n "$result" ]
}

# Bootstrap initial configuration to etcd
bootstrap_etcd_config() {
    log "Bootstrapping initial configuration to etcd..."

    ETCD_AUTH=""
    if [ -n "$ETCD_ROOT_PASSWORD" ]; then
        ETCD_AUTH="--user=root:$ETCD_ROOT_PASSWORD"
    fi

    # Basic Pingap configuration
    log "Writing basic.toml..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/basic.toml" '
# Pingap Basic Configuration
# Auto-generated by entrypoint-etcd.sh

[basic]
name = "alternatefutures-proxy"
error_template = ""
pid_file = "/var/run/pingap.pid"
upgrade_sock = "/tmp/pingap_upgrade.sock"
threads = 4
work_stealing = true
grace_period = "30s"
graceful_shutdown_timeout = "10s"
log_level = "info"
log_format_json = false
sentry = ""
'

    # Certificate configuration
    log "Writing certificate configuration..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/certificates/alternatefutures.toml" "
[certificates.alternatefutures]
tls_cert = \"$CERT_DIR/origin.crt\"
tls_key = \"$CERT_DIR/origin.key\"
"

    # Shared IPFS gateway upstream
    log "Writing IPFS gateway upstream..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/upstreams/ipfs-gateway.toml" '
[upstreams.ipfs-gateway]
addrs = ["gateway.pinata.cloud:443"]
sni = "gateway.pinata.cloud"
health_check = "/ipfs/QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn"
connection_timeout = "10s"
total_connection_timeout = "30s"
read_timeout = "30s"
idle_timeout = "60s"
'

    # Shared Arweave gateway upstream
    log "Writing Arweave gateway upstream..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/upstreams/arweave-gateway.toml" '
[upstreams.arweave-gateway]
addrs = ["arweave.net:443"]
sni = "arweave.net"
health_check = "/"
connection_timeout = "10s"
total_connection_timeout = "30s"
read_timeout = "30s"
idle_timeout = "60s"
'

    # Core service: Auth
    log "Writing auth service upstream..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/upstreams/auth.toml" '
[upstreams.auth]
addrs = ["auth-service.internal:3000"]
health_check = "/health"
connection_timeout = "5s"
total_connection_timeout = "10s"
read_timeout = "30s"
idle_timeout = "60s"
'

    # Core service: API
    log "Writing api service upstream..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/upstreams/api.toml" '
[upstreams.api]
addrs = ["api-service.internal:4000"]
health_check = "/health"
connection_timeout = "5s"
total_connection_timeout = "10s"
read_timeout = "30s"
idle_timeout = "60s"
'

    # Health check location
    log "Writing health check location..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/locations/health.toml" '
[locations.health]
path = "/health"
'

    # Auth location
    log "Writing auth location..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/locations/auth.toml" '
[locations.auth]
upstream = "auth"
host = "auth.alternatefutures.ai"
path = "~/"
proxy_set_headers = [
    "X-Forwarded-Proto: https",
    "X-Real-IP: $remote_addr"
]
'

    # API location
    log "Writing api location..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/locations/api.toml" '
[locations.api]
upstream = "api"
host = "api.alternatefutures.ai"
path = "~/"
proxy_set_headers = [
    "X-Forwarded-Proto: https",
    "X-Real-IP: $remote_addr"
]
'

    # HTTPS server
    log "Writing HTTPS server configuration..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/servers/https.toml" '
[servers.https]
addr = "0.0.0.0:443"
tls_cert = "alternatefutures"
locations = ["auth", "api", "health"]
threads = 2
'

    # Health check server (HTTP)
    log "Writing health server configuration..."
    etcdctl --endpoints="$ETCD_ADDR" $ETCD_AUTH put "$ETCD_PREFIX/servers/health.toml" '
[servers.health]
addr = "0.0.0.0:8080"
locations = ["health"]
threads = 1
'

    log "Bootstrap configuration complete"
}

# Start Pingap with etcd backend
start_pingap() {
    log "Starting Pingap with etcd backend..."
    log "etcd address: $ETCD_ADDR"
    log "etcd prefix: $ETCD_PREFIX"
    log "Admin interface: $ADMIN_ADDR"

    # Build etcd connection string
    ETCD_URL="etcd://${ETCD_ADDR#http://}${ETCD_PREFIX}"

    # Add authentication if provided
    if [ -n "$ETCD_ROOT_PASSWORD" ]; then
        ETCD_URL="etcd://root:${ETCD_ROOT_PASSWORD}@${ETCD_ADDR#http://}${ETCD_PREFIX}"
    fi

    log "Starting: pingap -c $ETCD_URL --autoreload --admin $ADMIN_ADDR"

    exec pingap \
        -c "$ETCD_URL" \
        --autoreload \
        --admin "$ADMIN_ADDR" \
        --log-level info
}

# Main
main() {
    log "=== AlternateFutures Dynamic Proxy Starting ==="
    log "Pingap + etcd configuration"

    write_certificates
    wait_for_etcd

    if etcd_has_config; then
        log "Existing configuration found in etcd, skipping bootstrap"
    else
        log "No existing configuration found, bootstrapping..."
        bootstrap_etcd_config
    fi

    start_pingap
}

main "$@"
